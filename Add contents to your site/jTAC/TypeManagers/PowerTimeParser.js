// jTAC/TypeManagers/PowerTimeParser.js
/* -----------------------------------------------------------
JavaScript Types and Conditions ("jTAC")
Copyright (C) 2012  Peter L. Blum

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------
Additional licensing:
Portions adapted from the commercial product, Peter's Data Entry Suite v5,
a product from Peter L. Blum who is the author of jTAC.
http://www.peterblum.com/des/home.aspx
Used by permission and covered by the same license as above.
-------------------------------------------------------------
Module: TypeManager objects
Class : TypeManger.PowerTimeParser

Purpose:
Parser of text representing time values, including time of day and duration.

It uses fuzzy logic to overlook minor errors and missing values.
It handles entries from users that may not match the intended
pattern but are legal.

For example, if the user types "A" (instead of "AM"),
it recognizes the element. You can customize how flexible it is
with the properties of the [config] property of the TypeManager passed to it.

Fuzzy logic cases:
- Can omit "AM" and "PM" in 12 hour format. It uses a default based on options.
- "AM" and "PM" can be shorted to their first letter and case does not matter.
- Does not require a space separator between AM/PM and the number
- Recognizes hours between 12 and 23 as PM times when "PM" is not entered.
- Can omit minutes and seconds. They will default to zero.
- Allows spaces around the time separators: "01 : 25 : 00".
- The user can omit time separator characters. A pattern like 012500 will
  know its 01:25:00.
- NOTE: The base class, TypeManagers.BaseTime, handles another case with its DecimalCharacterMode property.
  It allows decimal format entry for time. (1.5 = 1:30:00).

These classes to use localization data from the owner, which is a TypeManager.BaseDatesAndTimes subclass.

Caveats:
- The server side code must also be able to handle text that was accepted by this
  in its server side validation and string conversion.
  It is valuable to replace the contents of a textbox that have been parsed here
  with the string generated by the toString() method. This reformatting should
  occur on the textbox's onchange event. The datatypeeditor plugin
  takes advantage of this.
  However, the server side should still anticipate the textbox has not been reformatted.
- If you need a stricter parser, consider using the original classes or write your own.

See \jTAC\TypeManagers\Base.js for an overview of TypeManagers.

Properties introduced by this class:
   defaultAM (boolean) - 
      When using 12 hour format and AM/PM designator is omitted,
      this determines if the time means AM or PM. When true, it uses AM. False uses PM.
      When null, it is an error to omit the AM/PM designator.
      It defaults to true (AM).

   noSecsEnforced (boolean) - 
      When using TimeFormat=1 or 11, where no seconds are ever shown,
      this determines if their entry is illegal too.
      When false, the user can enter seconds and they will be kept.
      When true, if the user enters seconds of anything other than 0,
      it is an error. It defaults to true.

   moreTimeSeps (string) -
      User can enter additional time separator characters that are valid as a string. 
      This string consists of those time separator characters. 
      The characters are not delimited. All in the string are separators.

   insertTimeSeps (boolean) - 
      When there are no time separator characters found,
      insert time separator characters when true.
      It defaults to true.

   decimalCharacterMode (int)
      Time entry optionally permits the period character to be used in two ways:
      1) Allow decimal numbers for hours and minutes (1.5 = 1:30). Set this to 1.
      2) An alternative for the timeseparator (1.30 = 1:30). Set this to 2.
      When 0 (the default), decimal characters are not used unless they are the actual time separator.
      This is only used when converting string to number. It is not used to format a string from a number.
      It defaults to 0.

   trimParts (boolean) -
      When true, spaces are allowed around each part of the time.
      It defaults to false.
      This does not impact trimming lead and trailing spaces around the entire string. That always happens.

   fullAMPM (boolean) -
      When true, the AM/PM designator must be the full string. 
      When false, it can match with just the first character, allowing shorthand,
      and correcting typos.
      It defaults to false.

Properties utilitized in the owning TypeManagers.BaseTime class:
   timeFormat (int) - Determines how to setup the time pattern.
      It is also used to format a string.
      Its values:
      0 - Includes seconds. Uses culture's choice of 12/24 hr format.
         Ex: hh:mm:ss tt; HH:mm:ss
      1 - Omits seconds. Uses culture's choice of 12/24 hr format.
         Ex: hh:mm tt; HH:mm
      2 - Same as 0 except it omits seconds when they are 0 (while formatting a string).

      10 - Duration includes seconds. A duration is always using the 24 hour clock format.
         When using a number to hold the value, it supports hours higher than 24.
      11 - Duration omits seconds.
      12 - Same as 0 except it omits seconds when they are 0.
      100 - Culture neutral pattern: H:mm:ss
      101 - Culture neutral pattern without seconds: H:mm

   parseTimeRequires (string) -
      When the time pattern has seconds,
      set this to "s" to require seconds be entered.
      When "m", minutes are required but not seconds.
      When "h", only hours are required.
      It defaults to "m".

Requires: 
ALWAYS LOAD jTAC.js BEFORE THIS FILE IS LOADED
TypeManagers.Base
TypeManagers.BaseCulture
TypeManagers.BaseDatesAndTimes

----------------------------------------------------------- */
jTAC.require("TypeManagers.BaseTime");

jTAC._internal.temp._TypeManagers_PowerTimeParser = {

   constructor: function ( propertyVals ) {
      if (propertyVals != null)
         owner = propertyVals.owner;
   },

   config: {
      defaultAM: true,
      noSecsEnforced: true,
      moreTimeSeps: null,
      insertTimeSeps: true,
      trimParts: false,
      decimalCharacterMode: 0,
      fullAMPM: false
   },

   configrules: {
      defaultAM: jTAC.checkAsBoolOrNull,
      moreTimeSeps: jTAC.checkAsStrOrNull,
      decimalCharacterMode: [0, 1, 2]
   },

/* REQUIRED to use with jTAC.PluginParser object
Reference to the TypeManager that owns this. It should be based on BaseDatesAndTimes.
*/
   owner: null,

/* REQUIRED to use with jTAC.PluginParser object
   Parses the text to determine the time it represents. Uses fuzzy logic.
   Throws exceptions for illegal values.
      text (string) - text to parse.
      pat (string) - the time pattern to parser
   Returns an object that reflects each element of time. Its properties
   are "h", "m", "s" and "time". Time is the number of seconds reflected
   by the other values.
*/
   parse: function (text) {
      var owner = this.owner;

      if (!owner)
         this._error("Must assign the owner field.");

      var r,
      tSep = owner.dateTimeFormat("TimeSep"),
      opt = this.config;

      text = jTAC.trimStr(text);
      if (!text)
         return null;

      text = this._applyDCMode(text);  // returns either a string or the object expected by the caller
      if (typeof text == "object")
         return text;

      // using more Time Separators. If any are found, replace them with the default TimeSeparator
      if (opt.moreTimeSeps) {
         var re = new RegExp("[" + jTAC.escapeRE(opt.moreTimeSeps) + "]", "ig");
         text = text.replace(re, tSep);
      }

      // insert time separators if none are present
      if (opt.insertTimeSeps && (text.length > 2) && (text.indexOf(tSep) == -1))
         text = this._insertTSeps(text);

      var i, v, part,
      r = {h: 0, m: null, s: null}, // holds the resulting h, m, s
      order = owner._patternOrder(false, "Hhms"),  // omits 't' because the AM/PM designator's position is ignored and handled in _correctHours
      parts = this._splitParts(text);

      if (order.indexOf("s") == -1) { // allow seconds even without the pattern supporting it. Later NoSecsEnforced=true will invalidate seconds other than 0.
         order.push("s");
      }

      if (parts.length > order.length) // cannot have more parts than the order allows, but you can have fewer parts than order (because missing values are handled)
         this._inputError("Too many parts with digits");

      for (i = 0; (i < parts.length); i++) {
         part = parts[i];
         if (part == null) // part was not entered
            continue;
         v = parseInt(part, 10);
         if (isNaN(v) || (v < 0))
            this._inputError("Could not convert [" + part + "] to digits");
         else {
            r[order[i].toLowerCase()] = v;
            switch (order[i]) {
               case 's':
                  if (v > 59)
                     this._inputError("Seconds exceed 59");
                  break;

               case 'm':
                  if (v > 59)
                     this._inputError("Minutes exceed 59");
                  break;

               case 'h':
               case 'H':
/* This test is delegated to the caller
                  if (v > this.getMaxHours())
                     this._inputError("Hours exceed " + this.getMaxHours());
*/
                  break;

            }  // switch
         }  // else
      }  // for i

      var ptr = owner.getParseTimeRequires();
      if (r.m == null) {
         if (ptr != "h") 
            this._inputError("Minutes are required.");
         r.m = 0;
      }
      if (r.s == null) {
         if (ptr == "s") 
            this._inputError("Seconds are required.");
         r.s = 0;
      }

   // When timeformats don't allow seconds, respect that if seconds are non-zero
   // and config.noSecsEnforced is true.
      if (r.s && opt.noSecsEnforced && ((owner.getTimeFormat() % 10) == 1))
         this._inputError("Seconds cannot be assigned");

      if (owner._isTOD()) {
         r.h = this._correctHours(r.h, text);
      }

      r.time = r.h * 3600 + r.m * 60 + r.s;
      return r;
   },

/*
   Finalizes the value of hours when less than 12. It uses the AM/PM designators if available.
   If hours are already 13 or higher, it doesn't need AM/PM and the value is returned unchanged.
      hr (int) - The value of hours to review.
      text (string) - the string to evaluate for the designator.
*/
   _correctHours : function(hr, text) {
      var owner = this.owner;

   // check for AM/PM, even in military time...
   // if it has hours > 12 and 'AM', let military hours override AM symbol
      var hasAM = this._hasDesig("AM", text),
      hasPM = this._hasDesig("PM", text);

      if (!owner._isTOD() && (hasAM || hasPM))
         this._inputError("AM/PM designator not allowed in duration.");

      if (hr > 23)
         this._inputError("Hours exceeds 23.");
      if (hr > 12)
         return hr;

      if (hasAM && hasPM)
         hasPM = false;
      else if (!hasAM && !hasPM) {
         var t24 = owner._timePattern().indexOf("H") > -1;
         if (t24)
            return hr;

         var opt = this.config;
         if (opt.defaultAM == null) {
            this._inputError("Cannot determine hours as AM or PM");
         }
         else      
            hasPM = !opt.defaultAM;
      }
      // add PM hours if applicable
      if (hasPM && (hr < 12)) {
         hr = hr + 12;
      }
      else if (hasAM && (hr == 12)) { // 12AM
         hr = 0;
      }
      return hr;
   },

/*
   Attempt to match the culture specific AM/PM designator to content of text.
   If there is a match, it returns true.
      desName (string) - either "AM" or "PM" case sensitive
      text (string) - the string to evaluate for the designator.
   This class uses the following rules:
      - It matches case insensitively
      - Try an identical match. 
      - If config.fullAMPM is false, also try to find the first character of the designator
        in the text.
*/
   _hasDesig : function (desName, text) {
      var owner = this.owner;

   // des is an array of valid forms. Use the first, converted to uppercase
      var am = owner.dateTimeFormat("AM"),
      pm = owner.dateTimeFormat("PM"),
      des = desName == "AM" ? am : pm,
      r, textuc;
      if (!des) return false;
      des = des.toUpperCase();

      textuc = text.toUpperCase();
      r = textuc.indexOf(des) > -1;
      if (!r && (des.length > 1) && !this.config.fullAMPM) {   // check for the first character. It may be anywhere
         if (am.charAt(0) != pm.charAt(0)) {	// Korean uses identical first characters
            r = textuc.indexOf(des.charAt(0)) > -1;
         }
      }

      return r;
   },

   /*
   Returns an array of each part - hour, minute, second - found in the text.
   If any part is missing, it returns null for that part.
   It assumes all three are digits with the time separator between them.
   Optionally there can be spaces around the time separator.
   If not found, it returns null.
   There are can be fewer than all 3 parts, but it must find at least one set of digits,
   which is considered hours.
   The order of these parts should be mapped to the value returned by _timeOrder().
      text (string) - the string to evaluate for the designator.
   */
   _splitParts : function(text) {
      var owner = this.owner;

      var re = this._cache.splitRE;
      if (!re) {
         var tSep = owner.dateTimeFormat("TimeSep"),
         tSepEsc = jTAC.escapeRE(tSep),
         tSE2 = tSepEsc;
         // are spaces around each part allowed? 
         // Note: later, parseInt() is used. It ignores lead spaces as it processes the number.
         // This leads to it always allowing spaces. So this code will eliminate that case when not desired.
         if (this.config.trimParts && (tSep != " ")) {
            tSE2 = "\\s?" + tSepEsc + "\\s?";
         }
        // hours are required. Minutes and seconds optional
        // If there are illegal characters in the minutes or seconds parts, they are ignored. So the
        // first and last parts of this Reg ex looks for any digits or time separator outside of those it extracts.
        // If there are, it knows there was illegal text inside the minutes or seconds parts and returns an error
         re = this._cache.splitRE = new RegExp("^[^\\d" + tSepEsc + "]*(\\d+)(" + tSE2 + "(\\d*)(" + tSE2 + "(\\d*))?)?[^\\d" + tSepEsc + "]*$"); 
      }
      var m = re.exec(text);
      if (m) {
         return [m[1] || null, m[3] || null, m[5] || null];  // missing parts use "0"
      }
      this._inputError("Cannot extract the h/m/s parts");
   },

   /*
   Call when there are no time separators present. 
   It adds them and returns the updated string. 
   */
   _insertTSeps: function (text) {
      var owner = this.owner;

      var res = /\d+/.exec(text);
      if (!res)
         return text;
      var digits = res[0];
      var h = (digits.length % 2 == 0) ? digits.substr(0, 2) : digits.substr(0, 1);
      var m = digits.substr(h.length, 2);
      var s = "";
      var remainder = digits.length - (h.length + m.length);
      if (remainder > 0) {
         s = digits.substr(h.length + m.length, remainder);
      }
      var tSep = owner.dateTimeFormat("TimeSep");
      var repl = h;
      if (m != "") {
         repl += tSep + m;
         if (s != "") {
            repl += tSep + s;
         }
      }
/*
      if (!m) {
         m = "0";
      }
      if (!s) {
         s = "0";
      }
      var tSep = owner.dateTimeFormat("TimeSep");
      var repl = h + tSep + m + tSep + s;
*/
      return text.replace(digits, repl);

   },

/*
   Handles how the decimalCharacterMode impacts the string passed.
   The values it returns can be a string or an object that the parser can
   return directly. 
*/
   _applyDCMode : function ( text ) {
      var dcm = this.getDecimalCharacterMode();
      if (dcm != 0) {
         var owner = this.owner;

         var dSep = owner.numberFormat("DecimalSep");
         var tSep = owner.dateTimeFormat("TimeSep");
         if ((text.indexOf(dSep) > -1) && (dSep != tSep)) {
            switch (dcm) {
               case 1:  // process as a float where the whole digits are the hours and decimal is a portion of an hour.
                  var tm = this._cache.floattm;
                  if (!tm) {
                     jTAC.require("TypeManagers.Float");
                     tm = this._cache.floattm = jTAC.create("TypeManagers.Float");
                     tm.setCultureName(owner.getCultureName());
                  }
                  var r = tm.toValue(text);  // will throw exceptions for errors
                  if (!r)
                     this._inputError("Could not convert decimal value");
                  r = r * 3600;  // r is a value in hours. Convert to seconds
                  var h = Math.floor(r / 3600);
                  var m = Math.floor((r % 3600) / 60);
                  var s = Math.floor(r % 60);

                  return {h: h, m: m, s: s};
               case 2:  // replace period with time separator
                  text = jTAC.replaceAll(text, dSep, tSep, true);
                  break;
            }  // switch
         }  // if
      }

      return text;
   },


/* REQUIRED to use with jTAC.PluginParser object
   Returns a string of characters that are valid for this parser.
      orig (string) - the characters already defined by BaseTime._valChars.
         Its value can be modified or replaced.
*/
   valChars: function(orig) {
      return (this.getDecimalCharacterMode() != 0) ?
            orig + this.owner.numberFormat("DecimalSep") : orig;
   }

   /* --- PROPERTY GETTER AND SETTER METHODS ---------------------------
   These members are GETTER and SETTER methods associated with properties
   of this class.
   Not all are defined here. Any that are defined in this.config
   can be setup by the autoGet and autoSet capability. If they are, they 
   will not appear here.
   ---------------------------------------------------------------------*/

}
jTAC.define("TypeManagers.PowerTimeParser", jTAC._internal.temp._TypeManagers_PowerTimeParser);

jTAC.plugInParser("TypeManagers.PowerTimeParser", "TypeManagers.BaseTime");
